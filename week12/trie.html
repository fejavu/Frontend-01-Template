<script>
  class Trie {
    constructor() {
      this.root = Object.create(null);
    }

    insert(word) {
      let node = this.root;
      for(let char of word) {
        if(!node[char]) {
          node[char] = Object.create(null);
        }
        node = node[char];
      }

      if(!("$" in node)) {
        node["$"] = 0;
      } else {
        node["$"]++;
      }
    }

    most() {
      let max = 0;
      let maxWorld = null;
      let visit = (node, word) => {
        if(node.$ && node.$ > max) {
          max = node.$;
          maxWorld = word;
        }

        for(let p in node) {
          visit(node[p], word+p);
        }
      }
      visit(this.root, "")
    }

  }

  function randomWorld(length) {

  }
  // 圆括号、方括号、花括号匹配

  function find_KMP(source, pattern) {
    for(let i = 0; i < source.length; i++) {
      let matched = true;
      for(let j = 0; j < pattern.length; j++) {
        if(source[i+j] !== pattern[j]) {
          matched = false;
          break;
        }
      }
      if(matched) {
        return true;
      }
    }
    return false;
  }

  function find_WildCard(source, pattern) {
    let startCount = 0;
    for(let i = 0; i < pattern.length; i++) {
      if(pattern[i] === "*") {
        startCount++;
      }
    }

    if(startCount === 0) {
      for(let i = 0; i < pattern.length; i++) {
        if(pattern[i] !== source[i] && pattern[i] !== "?") {
          return false;
        }
      }
      return;
    }

    let  i = 0;
    let lastIndex = 0;

    for(i = 0; pattern[i] !== "*"; i++) {
        if(pattern[i] !== source[i] && pattern[i] !== "?") {
          return false;
        }
    }

    lastIndex = i;

    for(let p = 0; p < startCount - 1; p++) {
      i++;
      let subPattern = "";
      while(pattern[i] !== "*") {
        subPattern += pattern[i];
        i++;
      }

      let reg = new RegExp(subPattern.replace(/\?/g, "[\\s\\S]"), "g");
      reg.lastIndex = lastIndex;
      
      console.log(reg.exec(source));
      lastIndex = reg.lastIndex;
    }

    for(let j = 0; j <= source.length - lastIndex && pattern[pattern.length-j] !== "*"; j++) {
      if(pattern[pattern.length-j] !== source[source.length -j] 
        && pattern[pattern.length - j] !== "?") {
        return false
      }
    }
    return true;
  }

  function LRzero(source) {
    let charStack = [];
    for(let char of source) {
      if(char === "(" || char === "[" || char === "{") {
        charStack.push(char);
      }
      if(char === ")") {
        if(charStack[charStack.length - 1] === "(") {
          charStack.pop();
        }
      }
      if(char === "]") {
        if(charStack[charStack.length - 1] === "[") {
          charStack.pop();
        }
      }
      if(char === "}") {
        if(charStack[charStack.length - 1] === "{") {
          charStack.pop();
        }
      }
    }

    if(charStack.length === 0) {
      return true;
    } else {
      return false;
    }
  }

</script>